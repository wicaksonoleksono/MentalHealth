<!-- app/templates/admin/settings/image_capture_tab.html -->
<div class="bg-gradient-to-r from-orange-50 to-red-50 rounded-xl p-8 border border-orange-100">
    <h3 class="text-2xl font-semibold text-gray-900 mb-4 flex items-center">
        <div class="w-10 h-10 bg-orange-500 rounded-lg flex items-center justify-center mr-4">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/>
            </svg>
        </div>
        Camera & Recording Configuration
    </h3>
    <p class="text-gray-600 mb-8">Configure camera and recording settings for emotion capture during assessments.</p>

    <div class="space-y-8">
        <!-- Enable/Disable Recording -->
        <div class="bg-white rounded-lg p-6 border border-orange-200">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h4 class="font-medium text-gray-900">Enable Recording</h4>
                    <p class="text-sm text-gray-600">Turn camera recording on or off globally</p>
                </div>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" name="enable_recording" value="true" 
                           {{ 'checked' if settings_data.enable_recording else '' }}
                           id="enable_recording_toggle"
                           class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-orange-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-orange-600"></div>
                </label>
            </div>
        </div>

        <!-- 🔬 SCIENTIFIC CAPTURE MODES -->
        <div class="bg-white rounded-lg p-6 border border-orange-200" id="capture_mode_section">
            <div class="flex items-center mb-4">
                <div class="w-8 h-8 bg-blue-500 rounded-lg flex items-center justify-center mr-3">
                    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"/>
                    </svg>
                </div>
                <h4 class="font-medium text-gray-900">Scientific Capture Mode</h4>
                <span class="ml-2 bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded">Newest feat</span>
            </div>
            <p class="text-gray-600 mb-6">Choose how emotion data is captured for optimal research analysis</p>
            
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                <!-- Interval-Based Capture -->
                <label class="relative">
                    <input type="radio" name="capture_mode" value="interval" 
                           {{ 'checked' if settings_data.capture_mode == 'interval' else '' }}
                           class="peer sr-only">
                    <div class="p-6 border-2 border-gray-200 rounded-xl cursor-pointer transition-all peer-checked:border-blue-500 peer-checked:bg-blue-50">
                        <div class="flex items-center mb-3">
                            <div class="w-8 h-8 bg-green-500 rounded-lg flex items-center justify-center mr-3">
                                <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                            </div>
                            <span class="font-semibold">Interval Mode</span>
                        </div>
                        <p class="text-sm text-gray-600 mb-2">📸 Pictures every X seconds</p>
                        <ul class="text-xs text-gray-500 list-disc list-inside space-y-1">
                            <li><strong>Best for:</strong> General emotional state</li>
                            <li><strong>Data:</strong> Baseline emotion tracking</li>
                            <li><strong>Storage:</strong> Predictable file sizes</li>
                            <li><strong>Analysis:</strong> Time-series patterns</li>
                        </ul>
                    </div>
                </label>

                <!-- Event-Driven Capture -->
                <label class="relative">
                    <input type="radio" name="capture_mode" value="event_driven" 
                           {{ 'checked' if settings_data.capture_mode == 'event_driven' else '' }}
                           class="peer sr-only">
                    <div class="p-6 border-2 border-gray-200 rounded-xl cursor-pointer transition-all peer-checked:border-purple-500 peer-checked:bg-purple-50">
                        <div class="flex items-center mb-3">
                            <div class="w-8 h-8 bg-purple-500 rounded-lg flex items-center justify-center mr-3">
                                <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                                </svg>
                            </div>
                            <span class="font-semibold">Event-Driven</span>
                        </div>
                        <p class="text-sm text-gray-600 mb-2">⚡ Pictures on user actions</p>
                        <ul class="text-xs text-gray-500 list-disc list-inside space-y-1">
                            <li><strong>Best for:</strong> Decision-making moments</li>
                            <li><strong>Data:</strong> Precise action correlation</li>
                            <li><strong>Storage:</strong> Variable based on activity</li>
                            <li><strong>Analysis:</strong> Behavioral triggers</li>
                        </ul>
                    </div>
                </label>

                <!-- Continuous Video -->
                <label class="relative">
                    <input type="radio" name="capture_mode" value="video_continuous" 
                           {{ 'checked' if settings_data.capture_mode == 'video_continuous' else '' }}
                           class="peer sr-only">
                    <div class="p-6 border-2 border-gray-200 rounded-xl cursor-pointer transition-all peer-checked:border-red-500 peer-checked:bg-red-50">
                        <div class="flex items-center mb-3">
                            <div class="w-8 h-8 bg-red-500 rounded-lg flex items-center justify-center mr-3">
                                <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                                </svg>
                            </div>
                            <span class="font-semibold">Video Mode</span>
                        </div>
                        <p class="text-sm text-gray-600 mb-2">🎥 Continuous recording</p>
                        <ul class="text-xs text-gray-500 list-disc list-inside space-y-1">
                            <li><strong>Best for:</strong> Complete behavioral analysis</li>
                            <li><strong>Data:</strong> Full interaction timeline</li>
                            <li><strong>Storage:</strong> High usage</li>
                            <li><strong>Analysis:</strong> Micro-expressions</li>
                        </ul>
                    </div>
                </label>
            </div>
        </div>

        <!-- ⚡ Event-Driven Settings -->
        <div class="bg-white rounded-lg p-6 border border-purple-200" id="event_driven_settings" style="display: none;">
            <div class="flex items-center mb-4">
                <svg class="w-6 h-6 text-purple-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                </svg>
                <h4 class="font-medium text-gray-900">Event Triggers Configuration</h4>
                <span class="ml-2 bg-purple-100 text-purple-800 text-xs font-medium px-2.5 py-0.5 rounded">Event based Logging</span>
            </div>
            
            <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <div class="flex items-start">
                    <svg class="w-5 h-5 text-blue-600 mt-0.5 mr-3 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <div>
                        <h5 class="font-medium text-blue-900 mb-1">🎯 Event-Driven Research</h5>
                        <p class="text-sm text-blue-800">Choose which user actions should trigger emotion capture. Each trigger captures the exact moment when users make decisions or interact, providing precise behavioral correlation data for research analysis.</p>
                    </div>
                </div>
            </div>

            <div class="space-y-6">
                <!-- PHQ-9 Button Clicks -->
                <div class="border border-gray-200 rounded-lg p-5">
                    <div class="flex items-start justify-between">
                        <div class="flex-1">
                            <div class="flex items-center mb-2">
                                <span class="text-lg mr-2">🟦</span>
                                <h5 class="font-medium text-gray-900">PHQ-9 Button Clicks</h5>
                                <span class="ml-2 bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded">Recommended</span>
                            </div>
                            <p class="text-sm text-gray-600 mb-3">Captures emotion exactly when users select PHQ-9 response options (0-3 scale).</p>
                            <div class="text-xs text-gray-500">
                                <strong>Research Value:</strong> Decision-making moments, hesitation analysis, emotional state during self-assessment<br>
                                <strong>Timing:</strong> Triggered on radio button clicks and form submissions<br>
                                <strong>File naming:</strong> <code>phq9_q3_event_button_click_timestamp.jpg</code>
                            </div>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer ml-4">
                            <input type="checkbox" name="capture_on_button_click" value="true" 
                                   {{ 'checked' if settings_data.capture_on_button_click else '' }}
                                   class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                </div>

                <!-- Chat Message Send -->
                <div class="border border-gray-200 rounded-lg p-5">
                    <div class="flex items-start justify-between">
                        <div class="flex-1">
                            <div class="flex items-center mb-2">
                                <span class="text-lg mr-2">💬</span>
                                <h5 class="font-medium text-gray-900">Chat Message Send</h5>
                                <span class="ml-2 bg-blue-100 text-blue-800 text-xs font-medium px-2 py-0.5 rounded">Communication</span>
                            </div>
                            <p class="text-sm text-gray-600 mb-3">Captures emotion when users send messages in open questions chat.</p>
                            <div class="text-xs text-gray-500">
                                <strong>Research Value:</strong> Communication emotional state, expression before/after sharing thoughts<br>
                                <strong>Timing:</strong> Triggered on message form submission and send button clicks<br>
                                <strong>File naming:</strong> <code>chat_ex2_event_message_send_timestamp.jpg</code>
                            </div>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer ml-4">
                            <input type="checkbox" name="capture_on_message_send" value="true" 
                                   {{ 'checked' if settings_data.capture_on_message_send else '' }}
                                   class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                </div>

                <!-- Question Start -->
                <div class="border border-gray-200 rounded-lg p-5">
                    <div class="flex items-start justify-between">
                        <div class="flex-1">
                            <div class="flex items-center mb-2">
                                <span class="text-lg mr-2">🚀</span>
                                <h5 class="font-medium text-gray-900">Question Start</h5>
                                <span class="ml-2 bg-yellow-100 text-yellow-800 text-xs font-medium px-2 py-0.5 rounded">Optional</span>
                            </div>
                            <p class="text-sm text-gray-600 mb-3">Captures initial emotional state when new questions or conversation turns begin.</p>
                            <div class="text-xs text-gray-500">
                                <strong>Research Value:</strong> Baseline emotion at question start, first impression analysis<br>
                                <strong>Timing:</strong> Triggered when new questions load or conversation phases begin<br>
                                <strong>File naming:</strong> <code>phq9_q1_event_question_start_timestamp.jpg</code>
                            </div>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer ml-4">
                            <input type="checkbox" name="capture_on_question_start" value="true" 
                                   {{ 'checked' if settings_data.capture_on_question_start else '' }}
                                   class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                </div>

                <!-- Typing Pause Detection -->
                <div class="border border-gray-200 rounded-lg p-5">
                    <div class="flex items-start justify-between">
                        <div class="flex-1">
                            <div class="flex items-center mb-2">
                                <span class="text-lg mr-2">⏸️</span>
                                <h5 class="font-medium text-gray-900">Typing Pause Detection</h5>
                                <span class="ml-2 bg-orange-100 text-orange-800 text-xs font-medium px-2 py-0.5 rounded">Advanced</span>
                            </div>
                            <p class="text-sm text-gray-600 mb-3">Captures emotion during typing pauses (2+ second breaks), indicating thinking or hesitation moments.</p>
                            <div class="text-xs text-gray-500">
                                <strong>Research Value:</strong> Cognitive processing moments, hesitation analysis, thinking patterns<br>
                                <strong>Timing:</strong> Triggered after 2 seconds of typing inactivity<br>
                                <strong>File naming:</strong> <code>chat_ex1_event_typing_pause_timestamp.jpg</code>
                            </div>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer ml-4">
                            <input type="checkbox" name="capture_on_typing_pause" value="true" 
                                   {{ 'checked' if settings_data.capture_on_typing_pause else '' }}
                                   class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Event Configuration Summary -->
            <div class="mt-6 p-4 bg-gray-50 rounded-lg">
                <h5 class="font-medium text-gray-900 mb-2">📈 Research Configuration Summary</h5>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <strong>Recommended for:</strong><br>
                        • Decision-making analysis<br>
                        • Behavioral correlation studies<br>
                        • Precise moment capture
                    </div>
                    <div>
                        <strong>Data output:</strong><br>
                        • High-precision timestamps<br>
                        • Event context metadata<br>
                        • Action-emotion correlation
                    </div>
                </div>
            </div>
        </div>

        <!-- Interval Capture Settings -->
        <div class="bg-white rounded-lg p-6 border border-green-200" id="interval_capture_settings" style="display: none;">
            <h4 class="font-medium text-gray-900 mb-4 flex items-center">
                <svg class="w-5 h-5 text-green-500 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                Interval Capture Settings
            </h4>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Capture Interval</label>
                    <div class="flex items-center space-x-3">
                        <input type="range" name="capture_interval" 
                               min="1" max="30" step="1"
                               value="{{ settings_data.capture_interval or 5 }}"
                               id="capture_interval_slider"
                               class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider">
                        <div class="min-w-0">
                            <span class="text-sm font-medium text-gray-900" id="interval_display">{{ settings_data.capture_interval or 5 }}</span>
                            <span class="text-sm text-gray-500">sec</span>
                        </div>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">How often to capture images (1-30 seconds)</p>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Image Quality</label>
                    <select name="image_quality" id="image_quality_select"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500">
                        <option value="0.6">Standard (60%) - Smaller files</option>
                        <option value="0.8" {{ 'selected' if settings_data.image_quality == 0.8 else '' }}>High (80%) - Recommended</option>
                        <option value="0.9" {{ 'selected' if settings_data.image_quality == 0.9 else '' }}>Very High (90%) - Extra detail</option>
                        <option value="1.0" {{ 'selected' if settings_data.image_quality == 1.0 else '' }}>Maximum (100%) - Largest files</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Video Recording Settings -->
        <div class="bg-white rounded-lg p-6 border border-orange-200" id="video_recording_settings">
            <h4 class="font-medium text-gray-900 mb-4">Video Recording Settings</h4>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Video Quality</label>
                    <select name="video_quality" id="video_quality_select"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500">
                        <option value="480p">SD (480p) - Smaller files</option>
                        <option value="720p" {{ 'selected' if settings_data.video_quality == '720p' else '' }}>HD (720p) - Recommended</option>
                        <option value="1080p" {{ 'selected' if settings_data.video_quality == '1080p' else '' }}>Full HD (1080p) - High quality</option>
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Video Format</label>
                    <select name="video_format" id="video_format_select"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500">
                        <option value="webm" {{ 'selected' if settings_data.video_format == 'webm' else '' }}>WebM - Best browser support</option>
                        <option value="webm;codecs=vp9" {{ 'selected' if settings_data.video_format == 'webm;codecs=vp9' else '' }}>WebM VP9 - Better compression</option>
                        <option value="webm;codecs=vp8" {{ 'selected' if settings_data.video_format == 'webm;codecs=vp8' else '' }}>WebM VP8 - Legacy support</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Common Settings -->
        <div class="bg-white rounded-lg p-6 border border-orange-200" id="common_settings">
            <h4 class="font-medium text-gray-900 mb-4">Camera Settings</h4>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Resolution</label>
                <select name="resolution" id="resolution_select"
                        class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500">
                    <option value="640x480">640x480 - Basic quality</option>
                    <option value="800x600">800x600 - Good quality</option>
                    <option value="1280x720" {{ 'selected' if settings_data.resolution == '1280x720' else '' }}>1280x720 - HD (recommended)</option>
                    <option value="1920x1080" {{ 'selected' if settings_data.resolution == '1920x1080' else '' }}>1920x1080 - Full HD</option>
                </select>
                <p class="text-xs text-gray-500 mt-1">Higher resolutions provide better quality but use more storage</p>
            </div>
        </div>

        <!-- Camera Test -->
        <div class="bg-white rounded-lg p-6 border border-orange-200" id="camera-test-section">
            <h4 class="font-medium text-gray-900 mb-4">Test Camera Settings</h4>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Camera Preview -->
                <div>
                    <div class="relative bg-gray-900 rounded-lg overflow-hidden mb-4" style="aspect-ratio: 4/3;">
                        <video id="videoPreview" 
                               autoplay muted 
                               class="w-full h-full object-cover hidden">
                        </video>
                        <canvas id="captureCanvas" class="hidden"></canvas>
                        <div id="camera-placeholder" 
                             class="absolute inset-0 flex items-center justify-center text-gray-400">
                            <div class="text-center">
                                <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                                </svg>
                                <p class="text-sm">Camera preview will appear here</p>
                                <button type="button" onclick="startCameraTest(event)" 
                                        class="mt-2 bg-orange-500 text-white px-4 py-2 rounded-lg text-sm hover:bg-orange-600">
                                    Start Camera Test
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Camera Controls -->
                    <div id="camera-controls" class="flex gap-2 hidden">
                        <!-- Image Mode Controls -->
                        <button type="button" id="capture-photo-btn" onclick="testCapture()" 
                                class="flex-1 bg-green-500 text-white py-2 px-4 rounded-lg hover:bg-green-600" style="display: none;">
                            📸 Take Photo
                        </button>
                        
                        <!-- Video Mode Controls -->
                        <button type="button" id="start-recording-btn" onclick="startVideoRecording()" 
                                class="flex-1 bg-red-500 text-white py-2 px-4 rounded-lg hover:bg-red-600" style="display: none;">
                            🎥 Start Recording
                        </button>
                        <button type="button" id="stop-recording-btn" onclick="stopVideoRecording()" 
                                class="flex-1 bg-gray-500 text-white py-2 px-4 rounded-lg hover:bg-gray-600" style="display: none;">
                            ⏹️ Stop Recording
                        </button>
                        
                        <!-- Common Controls -->
                        <button type="button" onclick="stopCameraTest()" 
                                class="flex-1 bg-red-500 text-white py-2 px-4 rounded-lg hover:bg-red-600">
                            Stop Preview
                        </button>
                    </div>
                </div>

                <!-- Test Results -->
                <div>
                    <h5 class="font-medium text-gray-900 mb-3">Test Results</h5>
                    <div class="space-y-3">
                        <!-- Captured Image Preview -->
                        <div id="captured-image-preview" class="bg-gray-100 rounded-lg p-4 hidden">
                            <img id="captured-image" class="w-full rounded border" style="max-height: 150px; object-fit: contain;">
                            <div id="capture-info" class="mt-2 text-xs text-gray-600"></div>
                        </div>
                        
                        <!-- Recorded Video Preview -->
                        <div id="captured-video-preview" class="bg-gray-100 rounded-lg p-4 hidden">
                            <video id="captured-video" controls class="w-full rounded border" style="max-height: 150px;">
                            </video>
                            <div id="recording-info" class="mt-2 text-xs text-gray-600"></div>
                        </div>
                        
                        <!-- Camera Info -->
                        <div class="bg-gray-50 rounded-lg p-4 text-sm">
                            <div class="grid grid-cols-2 gap-2" id="camera-info-grid">
                                <div><strong>Resolution:</strong> <span id="current-resolution">{{ settings_data.resolution or '1280x720' }}</span></div>
                                <div><strong>Mode:</strong> <span id="current-mode">{{ settings_data.recording_mode or 'capture' }}</span></div>
                                <div id="interval-info" style="display: none;"><strong>Interval:</strong> <span id="current-interval">{{ settings_data.capture_interval or 5 }}s</span></div>
                                <div id="image-quality-info" style="display: none;"><strong>Image Quality:</strong> <span id="current-image-quality">{{ (settings_data.image_quality * 100)|round if settings_data.image_quality else 80 }}%</span></div>
                                <div id="video-quality-info" style="display: none;"><strong>Video Quality:</strong> <span id="current-video-quality">{{ settings_data.video_quality or '720p' }}</span></div>
                                <div id="video-format-info" style="display: none;"><strong>Video Format:</strong> <span id="current-video-format">{{ settings_data.video_format or 'webm' }}</span></div>
                            </div>
                        </div>
                        
                        <!-- Error Display -->
                        <div id="camera-error" class="bg-red-50 border border-red-200 rounded-lg p-3 hidden">
                            <div id="error-message" class="text-sm text-red-700"></div>
                        </div>
                        
                        <!-- Success Message -->
                        <div id="camera-success" class="bg-green-50 border border-green-200 rounded-lg p-3 hidden">
                            <div class="text-sm text-green-700">✅ Camera test successful! Settings are working properly.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Storage Estimates -->
        <div class="bg-white rounded-lg p-6 border border-orange-200" id="storage_estimates">
            <h4 class="font-medium text-gray-900 mb-4">Storage Estimates</h4>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="bg-blue-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-blue-600" id="storage-5min">~5MB</div>
                    <div class="text-sm text-blue-700">5-minute assessment</div>
                </div>
                <div class="bg-green-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-green-600" id="storage-15min">~15MB</div>
                    <div class="text-sm text-green-700">15-minute assessment</div>
                </div>
                <div class="bg-purple-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-purple-600" id="storage-30min">~30MB</div>
                    <div class="text-sm text-purple-700">30-minute assessment</div>
                </div>
            </div>
            <p class="text-xs text-gray-500 mt-3">Estimates based on current settings. Actual sizes may vary.</p>
        </div>
    </div>
</div>

<script>
// Camera Test Functionality
let videoStream = null;
let isPreviewActive = false;
let mediaRecorder = null;
let recordedChunks = [];
let isRecording = false;

function getCurrentSettings() {
    return {
        enabled: document.querySelector('input[name="enable_recording"]')?.checked || false,
        captureMode: document.querySelector('input[name="capture_mode"]:checked')?.value || 'interval',
        interval: document.querySelector('input[name="capture_interval"]')?.value || 5,
        imageQuality: parseFloat(document.querySelector('select[name="image_quality"]')?.value || 0.8),
        videoQuality: document.querySelector('select[name="video_quality"]')?.value || '720p',
        videoFormat: document.querySelector('select[name="video_format"]')?.value || 'webm',
        resolution: document.querySelector('select[name="resolution"]')?.value || '1280x720',
        // Event triggers
        captureOnButtonClick: document.querySelector('input[name="capture_on_button_click"]')?.checked || false,
        captureOnMessageSend: document.querySelector('input[name="capture_on_message_send"]')?.checked || false,
        captureOnQuestionStart: document.querySelector('input[name="capture_on_question_start"]')?.checked || false
    };
}

function updateCurrentSettingsDisplay() {
    const settings = getCurrentSettings();
    
    // Update basic info
    document.getElementById('current-resolution').textContent = settings.resolution;
    
    // Update mode display with scientific names
    const modeNames = {
        'interval': 'Interval Mode (Timer-based)',
        'event_driven': 'Event-Driven Mode (Action-based)',
        'video_continuous': 'Video Mode (Continuous)'
    };
    document.getElementById('current-mode').textContent = modeNames[settings.captureMode] || 'Interval Mode';
    
    // Show/hide mode-specific info
    const intervalInfo = document.getElementById('interval-info');
    const imageQualityInfo = document.getElementById('image-quality-info');
    const videoQualityInfo = document.getElementById('video-quality-info');
    const videoFormatInfo = document.getElementById('video-format-info');
    
    if (settings.captureMode === 'interval') {
        // Interval mode - show interval and image quality
        intervalInfo.style.display = 'block';
        imageQualityInfo.style.display = 'block';
        videoQualityInfo.style.display = 'none';
        videoFormatInfo.style.display = 'none';
        
        document.getElementById('current-interval').textContent = settings.interval + 's';
        document.getElementById('current-image-quality').textContent = Math.round(settings.imageQuality * 100) + '%';
    } else if (settings.captureMode === 'event_driven') {
        // Event-driven mode - show image quality, hide interval
        intervalInfo.style.display = 'none';
        imageQualityInfo.style.display = 'block';
        videoQualityInfo.style.display = 'none';
        videoFormatInfo.style.display = 'none';
        
        document.getElementById('current-image-quality').textContent = Math.round(settings.imageQuality * 100) + '%';
    } else {
        // Video mode - show video quality and format, hide interval
        intervalInfo.style.display = 'none';
        imageQualityInfo.style.display = 'none';
        videoQualityInfo.style.display = 'block';
        videoFormatInfo.style.display = 'block';
        
        document.getElementById('current-video-quality').textContent = settings.videoQuality;
        document.getElementById('current-video-format').textContent = settings.videoFormat.toUpperCase();
    }
    
    // Update control buttons
    updateControlButtons();
    
    // Update storage estimates
    updateStorageEstimates();
}

function updateControlButtons() {
    const settings = getCurrentSettings();
    const captureBtn = document.getElementById('capture-photo-btn');
    const startRecordBtn = document.getElementById('start-recording-btn');
    const stopRecordBtn = document.getElementById('stop-recording-btn');
    
    if (settings.captureMode === 'video_continuous') {
        // Video mode - show recording buttons
        captureBtn.style.display = 'none';
        if (isRecording) {
            startRecordBtn.style.display = 'none';
            stopRecordBtn.style.display = 'block';
        } else {
            startRecordBtn.style.display = 'block';
            stopRecordBtn.style.display = 'none';
        }
    } else {
        // Interval or event-driven modes - show capture button
        captureBtn.style.display = 'block';
        startRecordBtn.style.display = 'none';
        stopRecordBtn.style.display = 'none';
    }
}

async function startCameraTest(event) {
    // Prevent form submission
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }
    
    console.log('startCameraTest() called'); // Debug log
    
    try {
        hideError();
        hideSuccess();
        
        const settings = getCurrentSettings();
        console.log('Current settings:', settings); // Debug log
        
        if (!settings.enabled) {
            showError('Recording is disabled. Please enable recording first.');
            return;
        }
        
        updateCurrentSettingsDisplay();
        
        console.log('Requesting camera permission...'); // Debug log
        
        const resolution = settings.resolution.split('x');
        const width = parseInt(resolution[0]);
        const height = parseInt(resolution[1]);
        
        // Request camera permission - this should trigger browser modal
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: width },
                height: { ideal: height },
                facingMode: 'user'
            }
        });

        console.log('Camera stream obtained successfully'); // Debug log
        
        videoStream = stream;
        const video = document.getElementById('videoPreview');
        video.srcObject = stream;
        
        // Show video, hide placeholder
        video.classList.remove('hidden');
        document.getElementById('camera-placeholder').classList.add('hidden');
        document.getElementById('camera-controls').classList.remove('hidden');
        
        isPreviewActive = true;
        console.log('Camera test started successfully'); // Debug log
        
    } catch (error) {
        console.error('Camera test error:', error); // Debug log
        showError('Camera access denied: ' + error.message + '. Please allow camera access and try again.');
        isPreviewActive = false;
    }
}

function stopCameraTest() {
    // Stop any recording first
    if (isRecording) {
        stopVideoRecording();
    }
    
    if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
    }
    
    // Hide video, show placeholder
    document.getElementById('videoPreview').classList.add('hidden');
    document.getElementById('camera-placeholder').classList.remove('hidden');
    document.getElementById('camera-controls').classList.add('hidden');
    
    // Hide captured results
    document.getElementById('captured-image-preview').classList.add('hidden');
    document.getElementById('captured-video-preview').classList.add('hidden');
    
    isPreviewActive = false;
    isRecording = false;
    hideError();
    hideSuccess();
}

async function testCapture() {
    if (!isPreviewActive) return;

    try {
        const settings = getCurrentSettings();
        const video = document.getElementById('videoPreview');
        const canvas = document.getElementById('captureCanvas');
        
        const resolution = settings.resolution.split('x');
        const width = parseInt(resolution[0]);
        const height = parseInt(resolution[1]);
        
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, width, height);
        
        canvas.toBlob(function(blob) {
            const dataUrl = canvas.toDataURL('image/jpeg', settings.imageQuality);
            
            // Show captured image
            document.getElementById('captured-image').src = dataUrl;
            
            const fileSizeKB = Math.round(blob.size / 1024);
            const qualityPercent = Math.round(settings.imageQuality * 100);
            document.getElementById('capture-info').textContent = 
                `${width}x${height}, ${qualityPercent}% image quality, ${fileSizeKB}KB`;
            
            // Hide video preview, show image
            document.getElementById('captured-video-preview').classList.add('hidden');
            document.getElementById('captured-image-preview').classList.remove('hidden');
            showSuccess();
            
        }, 'image/jpeg', settings.imageQuality);
        
    } catch (error) {
        showError('Failed to capture image: ' + error.message);
    }
}

async function startVideoRecording() {
    if (!isPreviewActive || isRecording) return;

    try {
        const settings = getCurrentSettings();
        recordedChunks = [];
        
        // Determine MIME type based on format
        const mimeType = settings.videoFormat === 'mp4' 
            ? 'video/mp4' 
            : 'video/webm';
        
        mediaRecorder = new MediaRecorder(videoStream, {
            mimeType: mimeType
        });
        
        mediaRecorder.ondataavailable = function(event) {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };
        
        mediaRecorder.onstop = function() {
            const blob = new Blob(recordedChunks, { type: mimeType });
            const videoUrl = URL.createObjectURL(blob);
            
            // Show recorded video
            const capturedVideo = document.getElementById('captured-video');
            capturedVideo.src = videoUrl;
            
            const fileSizeMB = (blob.size / (1024 * 1024)).toFixed(2);
            const resolution = settings.resolution;
            const quality = settings.videoQuality;
            const format = settings.videoFormat.toUpperCase();
            
            document.getElementById('recording-info').textContent = 
                `${resolution}, ${quality} ${format} video, ${fileSizeMB}MB`;
            
            // Hide image preview, show video
            document.getElementById('captured-image-preview').classList.add('hidden');
            document.getElementById('captured-video-preview').classList.remove('hidden');
            showSuccess();
        };
        
        mediaRecorder.start();
        isRecording = true;
        updateControlButtons();
        
    } catch (error) {
        showError('Failed to start video recording: ' + error.message);
    }
}

function stopVideoRecording() {
    if (!isRecording || !mediaRecorder) return;
    
    mediaRecorder.stop();
    isRecording = false;
    updateControlButtons();
}

function showError(message) {
    document.getElementById('error-message').textContent = message;
    document.getElementById('camera-error').classList.remove('hidden');
}

function hideError() {
    document.getElementById('camera-error').classList.add('hidden');
}

function showSuccess() {
    document.getElementById('camera-success').classList.remove('hidden');
}

function hideSuccess() {
    document.getElementById('camera-success').classList.add('hidden');
}

function updateStorageEstimates() {
    const settings = getCurrentSettings();
    
    document.getElementById('storage-5min').textContent = calculateStorage(5);
    document.getElementById('storage-15min').textContent = calculateStorage(15);
    document.getElementById('storage-30min').textContent = calculateStorage(30);
}

function calculateStorage(minutes) {
    const settings = getCurrentSettings();
    let sizeKB = 0;
    
    if (settings.captureMode === 'interval') {
        // Interval mode: Regular timed captures
        const capturesPerMinute = 60 / settings.interval;
        const totalCaptures = capturesPerMinute * minutes;
        const avgImageSize = getImageSizeEstimate(settings);
        sizeKB = totalCaptures * avgImageSize;
    } else if (settings.captureMode === 'event_driven') {
        // Event-driven mode: Variable based on user activity
        // Estimate: ~2-8 captures per minute depending on activity
        const avgCapturesPerMinute = 4; // Conservative estimate
        const totalCaptures = avgCapturesPerMinute * minutes;
        const avgImageSize = getImageSizeEstimate(settings);
        sizeKB = totalCaptures * avgImageSize;
    } else {
        // Video continuous mode: Full video recording
        const avgVideoSizeMB = getVideoSizeEstimate(settings);
        sizeKB = avgVideoSizeMB * minutes * 1024;
    }
    
    if (sizeKB > 1024) {
        return Math.round(sizeKB / 1024) + 'MB';
    } else {
        return Math.round(sizeKB) + 'KB';
    }
}

function getImageSizeEstimate(settings) {
    const baseSizes = {
        '640x480': 25,
        '800x600': 40,
        '1280x720': 60,
        '1920x1080': 120
    };
    
    return (baseSizes[settings.resolution] || 60) * settings.imageQuality;
}

function getVideoSizeEstimate(settings) {
    const baseSizes = {
        '480p': 2,
        '720p': 4,
        '1080p': 8
    };
    
    const multiplier = settings.videoFormat === 'mp4' ? 1.2 : 1.0;
    return (baseSizes[settings.videoQuality] || 4) * multiplier;
}

function toggleSectionVisibility() {
    const enabled = document.getElementById('enable_recording_toggle').checked;
    console.log('Recording enabled:', enabled); // Debug log
    
    const sections = [
        'capture_mode_section',
        'interval_capture_settings', 
        'event_driven_settings',
        'video_recording_settings',
        'common_settings',
        'camera-test-section',
        'storage_estimates'
    ];
    
    sections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
            section.style.display = enabled ? 'block' : 'none';
            console.log(`Section ${sectionId} display:`, section.style.display); // Debug log
        }
    });
    
    // Update mode-specific sections
    if (enabled) {
        toggleModeSpecificSettings();
    }
    
    // Stop camera if disabling recording
    if (!enabled && isPreviewActive) {
        stopCameraTest();
    }
}

function toggleModeSpecificSettings() {
    const captureMode = document.querySelector('input[name="capture_mode"]:checked')?.value || 'interval';
    
    const intervalSettings = document.getElementById('interval_capture_settings');
    const eventDrivenSettings = document.getElementById('event_driven_settings');
    const videoSettings = document.getElementById('video_recording_settings');
    
    // Hide all mode-specific sections first
    if (intervalSettings) intervalSettings.style.display = 'none';
    if (eventDrivenSettings) eventDrivenSettings.style.display = 'none';
    if (videoSettings) videoSettings.style.display = 'none';
    
    // Show appropriate section based on capture mode
    if (captureMode === 'interval' && intervalSettings) {
        intervalSettings.style.display = 'block';
    } else if (captureMode === 'event_driven' && eventDrivenSettings) {
        eventDrivenSettings.style.display = 'block';
    } else if (captureMode === 'video_continuous' && videoSettings) {
        videoSettings.style.display = 'block';
    }
    
    updateCurrentSettingsDisplay();
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    // Interval slider
    const intervalSlider = document.getElementById('capture_interval_slider');
    const intervalDisplay = document.getElementById('interval_display');
    
    if (intervalSlider && intervalDisplay) {
        intervalSlider.addEventListener('input', function() {
            intervalDisplay.textContent = this.value;
            updateCurrentSettingsDisplay();
        });
    }
    
    // Enable/disable toggle
    const enableToggle = document.getElementById('enable_recording_toggle');
    if (enableToggle) {
        enableToggle.addEventListener('change', toggleSectionVisibility);
        toggleSectionVisibility(); // Initial state
    }
    
    // Capture mode radio buttons
    const captureModeRadios = document.querySelectorAll('input[name="capture_mode"]');
    captureModeRadios.forEach(radio => {
        radio.addEventListener('change', toggleModeSpecificSettings);
    });
    toggleModeSpecificSettings(); // Initial state
    
    // Other settings changes
    const settingsInputs = document.querySelectorAll('select[name="resolution"], select[name="image_quality"], select[name="video_quality"], select[name="video_format"]');
    settingsInputs.forEach(input => {
        input.addEventListener('change', updateCurrentSettingsDisplay);
    });
    
    // Initial update
    updateCurrentSettingsDisplay();
});
</script>