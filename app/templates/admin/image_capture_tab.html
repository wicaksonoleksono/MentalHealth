<!-- app/templates/components/image_capture_tab.html -->
<div class="bg-gradient-to-r from-orange-50 to-red-50 rounded-xl p-6 border border-orange-100" x-data="imageCaptureSettings()">
    <h3 class="text-xl font-semibold text-gray-900 mb-4 flex items-center">
        <div class="w-8 h-8 bg-orange-500 rounded-lg flex items-center justify-center mr-3">
            <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0118.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/>
            </svg>
        </div>
        Recording Configuration
    </h3>
    <p class="text-gray-600 mb-6">Configure recording settings during assessment sessions.</p>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <!-- Settings Panel -->
        <div class="space-y-6">
            <!-- Recording Mode Toggle -->
            <div class="bg-white rounded-lg p-4 border border-gray-200">
                <label class="block text-sm font-medium text-gray-700 mb-3">Recording Mode</label>
                <div class="relative">
                    <div class="flex bg-gray-100 rounded-lg p-1">
                        <button type="button"
                                @click="settings.recordingMode = 'capture'"
                                :class="settings.recordingMode === 'capture' ? 'bg-orange-500 text-white shadow-sm' : 'text-gray-600 hover:text-gray-900'"
                                class="flex-1 px-4 py-2 rounded-md text-sm font-medium transition-all duration-200">
                            üì∏ Image Capture
                        </button>
                        <button type="button"
                                @click="settings.recordingMode = 'video'"
                                :class="settings.recordingMode === 'video' ? 'bg-orange-500 text-white shadow-sm' : 'text-gray-600 hover:text-gray-900'"
                                class="flex-1 px-4 py-2 rounded-md text-sm font-medium transition-all duration-200">
                            üé• Full Video
                        </button>
                    </div>
                    <input type="hidden" name="recording_mode" :value="settings.recordingMode">
                </div>
                <p class="text-xs text-gray-500 mt-2" x-text="settings.recordingMode === 'capture' ? 'Capture images at regular intervals' : 'Record continuous video throughout assessment'"></p>
            </div>

            <!-- Image Capture Settings (shown when capture mode) -->
            <div x-show="settings.recordingMode === 'capture'" x-transition class="space-y-4">
                <!-- Capture Interval -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Capture Interval (seconds)</label>
                    <div class="flex items-center space-x-3">
                        <input type="number" 
                               name="capture_interval" 
                               x-model="settings.captureInterval"
                               min="1" 
                               step="1"
                               class="w-20 p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-transparent text-center">
                        <span class="text-sm text-gray-600">seconds between captures</span>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">How often to capture images during assessment (minimum 1 second)</p>
                </div>
            </div>

            <!-- Video Settings (shown when video mode) -->
            <div x-show="settings.recordingMode === 'video'" x-transition class="space-y-4">
                <!-- Video Quality -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Video Quality</label>
                    <select name="video_quality" 
                            x-model="settings.videoQuality"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-transparent">
                        <option value="720p">HD (720p) - Recommended</option>
                        <option value="1080p">Full HD (1080p) - Higher quality</option>
                        <option value="480p">SD (480p) - Smaller files</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">720p provides good quality with manageable file sizes</p>
                </div>

                <!-- Video Format -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Video Format</label>
                    <select name="video_format" 
                            x-model="settings.videoFormat"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-transparent">
                        <option value="webm">WebM - Browser optimized</option>
                        <option value="mp4">MP4 - Universal compatibility</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">WebM works well in browsers, MP4 for broader compatibility</p>
                </div>
            </div>

            <!-- Common Settings -->
            <div class="space-y-4">
                <!-- Image/Video Quality -->
                <div x-show="settings.recordingMode === 'capture'">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Image Quality</label>
                    <select name="image_quality" 
                            x-model="settings.imageQuality"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-transparent">
                        <option value="0.8">High (80%) - Good for emotion detection</option>
                        <option value="0.9">Very High (90%) - Extra detail</option>
                        <option value="1.0">Maximum (100%) - Uncompressed</option>
                        <option value="0.7">Medium (70%) - Smaller files</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">80% quality preserves facial features well</p>
                </div>

                <!-- Resolution -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Resolution</label>
                    <select name="resolution" 
                            x-model="settings.resolution"
                            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-transparent">
                        <option value="640x480">640x480 - Good for emotion detection</option>
                        <option value="800x600">800x600 - Better detail</option>
                        <option value="1280x720">1280x720 - HD (recommended)</option>
                        <option value="1920x1080">1920x1080 - Full HD</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">720p is usually optimal for emotion analysis</p>
                </div>
            </div>


        </div>

        <!-- Camera Preview Panel -->
        <div class="space-y-4">
            <div class="flex items-center justify-between">
                <h4 class="font-medium text-gray-900">Camera Preview</h4>
                <button type="button"
                        @click="togglePreview()" 
                        :class="isPreviewActive ? 'bg-red-500 hover:bg-red-600' : 'bg-orange-500 hover:bg-orange-600'"
                        class="px-4 py-2 text-white rounded-lg font-medium transition-colors">
                    <span x-text="isPreviewActive ? 'Stop Preview' : 'Start Preview'"></span>
                </button>
            </div>

            <!-- Video Preview -->
            <div class="relative bg-gray-900 rounded-lg overflow-hidden" style="aspect-ratio: 4/3;">
                <video x-ref="videoPreview" 
                       x-show="isPreviewActive"
                       autoplay 
                       muted 
                       class="w-full h-full object-cover">
                </video>
                <div x-show="!isPreviewActive" 
                     class="absolute inset-0 flex items-center justify-center text-gray-400">
                    <div class="text-center">
                        <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                        </svg>
                        <p class="text-sm">Camera preview will appear here</p>
                    </div>
                </div>
            </div>

            <!-- Test Controls -->
            <div x-show="isPreviewActive" class="space-y-4">
                <!-- Test Capture/Recording Button -->
                <button type="button"
                        @click="testRecording()" 
                        :class="isRecording ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'"
                        class="w-full text-white py-3 rounded-lg font-medium transition-colors">
                    <span x-show="settings.recordingMode === 'capture' && !isRecording">üì∏ Test Image Capture</span>
                    <span x-show="settings.recordingMode === 'video' && !isRecording">üé• Start Test Recording</span>
                    <span x-show="isRecording">‚èπÔ∏è Stop Recording</span>
                </button>

                <!-- Recording Status -->
                <div x-show="isRecording" class="bg-red-50 border border-red-200 rounded-lg p-4">
                    <div class="flex items-center">
                        <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse mr-2"></div>
                        <span class="text-red-700 font-medium">Recording in progress...</span>
                        <span class="ml-auto text-red-600" x-text="recordingDuration + 's'"></span>
                    </div>
                </div>

                <!-- Captured Content Preview -->
                <div x-show="capturedContent" class="bg-gray-100 rounded-lg p-4">
                    <h5 class="font-medium text-gray-900 mb-2" x-text="settings.recordingMode === 'capture' ? 'Captured Image Preview' : 'Recorded Video Preview'"></h5>
                    
                    <!-- Image Preview -->
                    <img x-show="settings.recordingMode === 'capture' && capturedContent" 
                         :src="capturedContent" 
                         class="w-full rounded border" 
                         style="max-height: 200px; object-fit: contain;">
                    
                    <!-- Video Preview -->
                    <video x-show="settings.recordingMode === 'video' && capturedContent"
                           :src="capturedContent"
                           controls
                           class="w-full rounded border"
                           style="max-height: 200px;">
                    </video>
                    
                    <div class="mt-2 text-xs text-gray-600" x-show="contentInfo">
                        <p x-text="contentInfo"></p>
                    </div>
                </div>
            </div>

            <!-- Error Display -->
            <div x-show="error" class="bg-red-50 border border-red-200 rounded-lg p-4">
                <div class="flex">
                    <svg class="w-5 h-5 text-red-500 mt-0.5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
                    </svg>
                    <div class="text-sm text-red-700" x-text="error"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
function imageCaptureSettings() {
    return {
        settings: {
            recordingMode: '{{ recording_mode|default("capture") }}',
            captureInterval: parseInt('{{ capture_interval|default(5) }}'),
            imageQuality: parseFloat('{{ image_quality|default(0.8) }}'),
            resolution: '{{ resolution|default("1280x720") }}',
            videoQuality: '{{ video_quality|default("720p") }}',
            videoFormat: '{{ video_format|default("webm") }}',
            enableRecording: {{ 'true' if enable_recording else 'false' }}
        },
        isPreviewActive: false,
        isRecording: false,
        recordingDuration: 0,
        capturedContent: null,
        contentInfo: null,
        error: null,
        videoStream: null,
        mediaRecorder: null,
        recordingTimer: null,

        async togglePreview() {
            if (this.isPreviewActive) {
                this.stopPreview();
            } else {
                await this.startPreview();
            }
        },

        async startPreview() {
            try {
                this.error = null;
                const resolution = this.settings.resolution.split('x');
                const width = parseInt(resolution[0]);
                const height = parseInt(resolution[1]);
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: width },
                        height: { ideal: height },
                        facingMode: 'user'
                    },
                    audio: this.settings.recordingMode === 'video'
                });

                this.videoStream = stream;
                this.$refs.videoPreview.srcObject = stream;
                this.isPreviewActive = true;
                
            } catch (error) {
                this.error = 'Camera access denied or not available: ' + error.message;
                this.isPreviewActive = false;
            }
        },

        stopPreview() {
            if (this.isRecording) {
                this.stopRecording();
            }
            
            if (this.videoStream) {
                this.videoStream.getTracks().forEach(track => track.stop());
                this.videoStream = null;
            }
            this.isPreviewActive = false;
            this.capturedContent = null;
            this.contentInfo = null;
        },

        async testRecording() {
            if (this.settings.recordingMode === 'capture') {
                await this.testCapture();
            } else {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }
        },

        async testCapture() {
            if (!this.isPreviewActive) return;

            try {
                const video = this.$refs.videoPreview;
                const canvas = document.createElement('canvas');
                const resolution = this.settings.resolution.split('x');
                const width = parseInt(resolution[0]);
                const height = parseInt(resolution[1]);
                
                canvas.width = width;
                canvas.height = height;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, width, height);
                
                const self = this;
                canvas.toBlob(function(blob) {
                    self.capturedContent = canvas.toDataURL('image/jpeg', self.settings.imageQuality);
                    
                    const fileSizeKB = Math.round(blob.size / 1024);
                    const qualityPercent = Math.round(self.settings.imageQuality * 100);
                    self.contentInfo = `Resolution: ${width}x${height}, Quality: ${qualityPercent}%, Size: ${fileSizeKB}KB`;
                }, 'image/jpeg', this.settings.imageQuality);
                
            } catch (error) {
                this.error = 'Failed to capture image: ' + error.message;
            }
        },

        startRecording() {
            if (!this.videoStream) return;

            try {
                const options = {
                    mimeType: this.settings.videoFormat === 'mp4' ? 'video/mp4' : 'video/webm'
                };
                
                this.mediaRecorder = new MediaRecorder(this.videoStream, options);
                const chunks = [];
                
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) chunks.push(event.data);
                };
                
                this.mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: options.mimeType });
                    this.capturedContent = URL.createObjectURL(blob);
                    
                    const fileSizeMB = Math.round(blob.size / 1024 / 1024 * 100) / 100;
                    const resolution = this.settings.resolution;
                    const quality = this.settings.videoQuality;
                    this.contentInfo = `Resolution: ${resolution}, Quality: ${quality}, Duration: ${this.recordingDuration}s, Size: ${fileSizeMB}MB`;
                };
                
                this.mediaRecorder.start();
                this.isRecording = true;
                this.recordingDuration = 0;
                
                this.recordingTimer = setInterval(() => {
                    this.recordingDuration++;
                }, 1000);
                
            } catch (error) {
                this.error = 'Failed to start recording: ' + error.message;
            }
        },

        stopRecording() {
            if (this.mediaRecorder && this.isRecording) {
                this.mediaRecorder.stop();
                this.isRecording = false;
                
                if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                    this.recordingTimer = null;
                }
            }
        }
    };
}
</script>